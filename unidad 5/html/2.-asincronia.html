<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="../js/2.-asincronia.js" defer></script>
    <link rel="stylesheet" href="../css/estilos.css" type="text/css">
</head>
<body>
    <section class="contenedor-flex-columna gap">
        <head>
            <h2>Types of programming</h2>
            <ol>
                <li>Synchronous programming: i+1th line is executed after the ith has finished its execution. Some lines/functions take a long time (they have to wait for external resources, perform a lot of operations or it is just inefficient code), blocking the execution of the page</li>
                <li>Asynchronous programming: i+1th line is executed no matter if ith line has finished its execution</li>
                </ol>
            <h2>Asynchronous programming</h2>
            <ul>
                <li>A promise is an object returned by an asynchronous function that represents the current state of the operation</li>
                <li>A promise can be in three states
                    <ol>
                        <li>pending</li>
                        <li>fullfiled. The API has processed the request and it has replied. Even if it is a negative response (404 not found in fetch)</li>
                        <li>rejected. It provokes a call to catch handler</li>
                    </ol>
                </li>
            </ul>

            <h2>What is AJAX (Asynchronous JavaScript And XML)?</h2>
            <ul>
                <li>is a technique that allows retrieving specific parts from the server to update sections of a webpage without having to load an entire new page</li>
                <li>it saves a lot of bandwidth in data-oriented websites by avoiding server having to send again CSS, JS, HTML...</li>
                <li>In the past, it was used only with XML, but not anymore. It can be used with JSON, XML or text</li>
                <li>It was possible by using XMLHttpRequest API. Nowadays, fetch API is way more used. Therefore, AJAX is nothing else but performing asynchronous calls and upgrading just a part of the website rather than requesting the whole page</li>
            </ul>
        </head>
        <article class="contenedor-flex-columna gap borde jc-center">
            <h3>Synchronous code</h3>
            <p>Calculating, in a very unefficient way, a set of prime numbers</p>
            <label for="quota">Cantidad de números primos</label>
            <input type="text" id="primos" name="primos" value="1000000" />
            <button id="synchronous">Synchronous call</button>
            <p id='textoSíncrono' class="dp_none"></p>
            <textarea id="user-input-synchronous" rows="5" cols="62">Escribe algo mientras la función se ejecuta</textarea>
        </article>

        <article class="contenedor-flex-columna gap borde jc-center">
            <h3>Simple promise</h3>
            <p>A promise is an object returned by an asynchronous function that represents the current state of the operation</p>
            <button id="simplePromise">Simple promise</button>
            <p id='textoPromesaSimple' class="caja_mensajes"></p>
            <textarea id="user-input-synchronous" rows="5" cols="62">Escribe algo mientras la función se ejecuta</textarea>
        </article>

        <article class="contenedor-flex-columna gap borde jc-center">
            <h3>Asynchronous code</h3>
            <p>Await must preceede any function call that returns a promise to force the code to wait for this promise to be settled</p>
            <p>text asynchronous method has been used to get the response as string</p>
            <button id="asynchronousCode">Asynchronous code</button>
            <p id='textoAsíncrono' class="caja_mensajes"></p>
            <textarea id="user-input-synchronous" rows="5" cols="62">Escribe algo mientras la función se ejecuta</textarea>
        </article>

        <article class="contenedor-flex-columna gap borde jc-center">
            <h3>Reading an image</h3>
            <p>blob method is used for large objects like images or videos</p>
            <button id="getImage">Get image</button>
        </article>

        <article class="contenedor-flex-columna gap borde jc-center">
            <h3>Creating an asynchronous function</h3>
            <p>Place async before function declaration to make it asynchronous</p>
            <p>Besides, inside it, await must preceede any function call that returns a promise to force the code to wait for this promise to be settled</p>
            <p>try...catch can be used on async functions</p>
            <p>fetch is used to get a resource from a server. It returns a promise object of the built-in Response class as soon as the server responds with headers, but no body has still been transfered. 
            <p>In order to get the body, an additional method is required. Most used methods: text() and json()</p>
            <button id="asyncFunctions">async functions</button>
            <p id='textoFuncionAsíncrona' class="caja_mensajes"></p>
        </article>

        <article class="contenedor-flex-columna gap borde jc-center">
            <h3>Asynchronous code</h3>
            <p>Requesting a file using fetch</p>
            <p>fetch() returns a promise so a function must be passed into the then() method of the returned promise. This method will be called when the HTTP request has received a response from the server.</p>
            <button id="asynchronous">One single asynchronous call</button>
            <p id='textoAsíncrono' class="caja_mensajes"></p>
        </article>

        <article class="contenedor-flex-columna gap borde jc-center">
            <h3>Chaining promises</h3>
            <p>When using the fetch() method to make a request to a server, a promise is got back resolving to a Response object. This object represents the entire HTTP response, including the status, headers, and body. However, the body is not directly accessible as a string or an object, but rather as a stream of data that can only be read once.</p>
            <p>To handle the response body, it is needed to use one of the methods of the Response object that returns another promise that resolves to the parsed data. These methods are: json, text, blob, arrayBuffer and formData</p>

            <p>Promises can be chained if the output of one is to be processed by the next one</p>
            <p>Chaining promises to get a file and convert to JSON (an asynchronous method)</p>
            <button id="chainingPromises">Chaining promises</button>
            <p id='textoEncadenandoPromesas' class="caja_mensajes"></p>
        </article>

        <article class="contenedor-flex-columna gap borde jc-center">
            <h3>Combining promises</h3>
            <p>Promise.all takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when all of the input's promises fulfill. It rejects when any of the input's promises rejects, with this first rejection reason.</p>
            <p>Several promises can be fulfilled before doing something else even though they are not related</p>
            <button id="combiningAllPromises">Combining all unrelated promises</button>
            <p id='textoCombinandoTodasPromesas' class="caja_mensajes"></p>
        </article>

        <article class="contenedor-flex-columna gap borde jc-center">
            <h3>Combining promises</h3>
            <p>Requesting some files at the same time</p>
            <p>Promise.any takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when any of the input's promises fulfill. It rejects when all of the input's promises rejects, with this first rejection reason.</p>
            <p>Several promises can be fulfilled before doing something else even though they are not related</p>
            <button id="combiningAnyPromises">Combining any unrelated promises</button>
            <p id='textoCombinandoAlgunasPromesas' class="caja_mensajes"></p>
        </article>
    </section>
    
</body>
</html>